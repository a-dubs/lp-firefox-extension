// content.js
// import "lib/marked.min.js";
console.log("LP Firefox extension loaded")

// test pages:
// https://code.launchpad.net/~a-dubs/cloudware/+git/oraclelib/+merge/455155
// https://code.launchpad.net/~gjolly/cloudware/+git/cinteract/+merge/461516

const MICROSERVICE_BASE_URL = "http://localhost:8698";

var DIFF_TEXT = "";
var PREVIEW_DIFF_TEXTS = {};
var DONE_FETCHING_PREVIEW_DIFF_TEXTS = false;
var MP = {};
var INLINE_COMMENTS = [];
var DRAFT_INLINE_COMMENTS = [];
var GROUPED_INLINE_COMMENTS = {};
var GROUPED_DRAFT_INLINE_COMMENTS = {};
var MUGSHOT_URLS = {}; // map mugshot_url to local blob url
var CURRENT_DIFF_VIEW_SETTING = "unified"; // either "side-by-side" or "unified"
var MDconverter = new showdown.Converter();
MDconverter.setFlavor('github');
MDconverter.setOption("omitExtraWLInCodeBlocks", true);
MDconverter.setOption("strikethrough", true);
MDconverter.setOption("tables", true);

// ghMentionsLink: (string) [default https://github.com/{u}] Changes the link generated by @mentions. Showdown will replace {u} with the username. Only applies if ghMentions option is enabled. Example: @tivie with ghMentionsOption set to //mysite.com/{u}/profile will result in <a href="//mysite.com/tivie/profile">@tivie</a>



function cleanup_previous_elements() {
    console.log("cleaning up previous elements")
    // remove elements that may have been injected at a previous time
    if (document.querySelector("#ci_cd_status_row")) {
        document.querySelector("#ci_cd_status_row").remove()
    }
    if (document.querySelector("#custom-diff-area")) {
        document.querySelector("#custom-diff-area").remove()
    }
    // cleanup any comment cards that may have been created
    document.querySelectorAll(".d2h-code-comment-card").forEach(card => {
        card.remove();
    });
    if (document.querySelector("#diff-view-switcher")) {
        document.querySelector("#diff-view-switcher").remove();
    }
    if (document.querySelector(".show-old-diff-button")) {
        document.querySelectorAll(".show-old-diff-button").forEach(button => {
            button.remove();
        });
    }
    if (document.querySelector(".checkout-changes-locally-button")) {
        document.querySelectorAll(".checkout-changes-locally-button").forEach(button => {
            button.remove();
        });
    }
    if (document.querySelector(".checkout-changes-locally-row")) {
        document.querySelectorAll(".checkout-changes-locally-row").forEach(row => {
            row.remove();
        });
    }
    if (document.querySelectorAll(".hidden-diff-viewer")) {
        document.querySelectorAll(".hidden-diff-viewer").forEach(viewer => {
            viewer.remove();
        });
    }
}

//////////////////////////////// HELPERS //////////////////////////////////////

// take in fileName and preview_diff_id and return the file diff element
function findHiddenDiffElementByFileName(fileName, preview_diff_id) {
    const diffViewer = getHiddenDiffViewerElement(preview_diff_id);
    const file_diffs = diffViewer.querySelectorAll(".d2h-file-wrapper");
    for (const file_diff of file_diffs) {
        const file_name = get_file_name_from_diff_element(file_diff);
        if (file_name === fileName) {
            return file_diff;
        }
    }
    console.error(`file ${fileName} not found in hidden diff viewer for preview_diff_id ${preview_diff_id}`);
    return null;
}

// returns table row element
function findDiffLineElementByLineNumber(diffElement, lineNumber) {
    const tableRows = diffElement.querySelectorAll("tr");
    for (const row of tableRows) {
        if (parseInt(row.querySelector(".d2h-code-linenumber").innerText) === lineNumber) {
            return row;
        }
    };
    return null;
}

function get_file_name_from_diff_element(diff_element) {
    const file_name = diff_element.querySelector(".d2h-file-name").innerText;
    // if file has been renamed, use new file name as the file name
    if (file_name.includes("→")) {
        return file_name.split("→")[1].trim();
    }
    return file_name;
}

function getFileNameFromDiffLineElement(tr_element) {
    // use closest() to find the parent diff element with the class "d2h-file-wrapper"
    const file_diff = tr_element.closest(".d2h-file-wrapper");
    return get_file_name_from_diff_element(file_diff);
}

function getDraftInlineComment(preview_diff_id, line_number_in_original_diff) {
    for (const comment of DRAFT_INLINE_COMMENTS) {
        if (comment.preview_diff_id == preview_diff_id && comment.line_number_in_original_diff == line_number_in_original_diff) {
            return comment;
        }
    }
    return null;
}

////////////////////////////////////////////////////////////////////////////////

function renderDivsInnerTextAsMarkdown(querySelectorString) {
    const target_divs = document.querySelectorAll(querySelectorString);
    target_divs.forEach((div) => {
        const originalText = div.innerText;
        var html = MDconverter.makeHtml(originalText);
        div.innerHTML = html;
    });
}


function doMarkdownCommentsStuff() {
    renderDivsInnerTextAsMarkdown("#description .yui3-editable_text-text");
    renderDivsInnerTextAsMarkdown(".comment-text.editable-message-text");
}


function parseCICDState(comment) {
    return (comment.querySelector(".boardCommentActivity").innerText === "review: Approve (continuous-integration)") ? "Passing" : "Failing";
}


function replaceCICDComments() {
    const comments = document.querySelectorAll(".boardComment")
    var most_recent_ci_cd_state = "";
    var most_recent_ci_cd_job_link = "";
    // const most_recent_ci_cd_state
    comments.forEach(comment => {
        if (comment.querySelector(".boardCommentDetails a").innerText === "CPC CI Bot (cpc-ci-bot)") {
            most_recent_ci_cd_state = parseCICDState(comment)
            most_recent_ci_cd_job_link = comment.querySelector(".boardCommentBody a").href
            // comment.remove()
            comment.style.display = "none";
        }
    });
    console.log("CI/CD: " + most_recent_ci_cd_state)
    return { state: most_recent_ci_cd_state, link: most_recent_ci_cd_job_link }
}


function createNewCICDElement(state, link) {
    const newCICD = document.createElement("div")
    const target_table = document.querySelector("#proposal-summary");
    const table_body = target_table.querySelector("tbody");
    const new_row = document.createElement("tr");
    new_row.setAttribute("id", "ci_cd_status_row");
    const new_h = document.createElement("th");
    const new_td = document.createElement("td");
    new_h.innerText = "CI/CD Status:";
    const cicd_text = document.createElement("a");
    cicd_text.setAttribute("id", "ci_cd_status_text");
    cicd_text.innerText = state;
    cicd_text.classList.add(String(state).toLowerCase());
    cicd_text.href = link;
    cicd_text.target = "_blank";
    // insert as second row in table
    new_row.appendChild(new_h);
    new_td.appendChild(cicd_text);
    new_row.appendChild(new_td);
    table_body.insertBefore(new_row, table_body.childNodes[2]);

}


function parseDiffTextFromExistingDiv() {
    const diff = document.querySelector("#review-diff tbody").innerText
    const lines = document.querySelectorAll("#review-diff td.text")
    // get text from each line and combine into one string
    let diff_txt = "";
    lines.forEach(line => {
        // console.log(line.innerText)
        diff_txt += line.innerText + "\n"
    });
    // console.log(diff_txt)
    DIFF_TEXT = diff_txt;
    return diff_txt
}


function performDiffViewerMods(collapsedDiffIds) {

    // get all "headers" for each file's diff
    const diffArea = document.querySelector("#custom-diff-area");
    const headers = diffArea.querySelectorAll(".d2h-file-wrapper .d2h-file-name-wrapper")
    console.log(headers)
    headers.forEach(header => {
        const rightDiv = document.createElement("div");
        rightDiv.classList.add("right-div");
        const collapseButton = document.createElement("button");
        collapseButton.classList.add("collapse-button")
        collapseButton.addEventListener("click", () => {
            const parentDiffElement = header.parentElement.parentElement;
            const diffViewContent = parentDiffElement.querySelector(".d2h-files-diff") || parentDiffElement.querySelector(".d2h-file-diff")
            if (collapseButton.innerText === "Expand") {
                // diffViewContent.style.display = ""
                collapseButton.innerText = "Collapse"
                parentDiffElement.classList.remove("collapsed");
            }
            else {
                // diffViewContent.style.display = "none"
                collapseButton.innerText = "Expand"
                parentDiffElement.classList.add("collapsed");
            }
        });
        // apply collapsed state to any diffs that were previously collapsed
        const parentDiffElement = header.parentElement.parentElement;
        if (collapsedDiffIds.includes(parentDiffElement.id)) {
            collapseButton.innerText = "Expand";
            parentDiffElement.classList.add("collapsed");
            // const diffViewContent = parentDiffElement.querySelector(".d2h-files-diff") || parentDiffElement.querySelector(".d2h-file-diff");

            // diffViewContent.style.height = 0;
            // diffArea.querySelector(".d2h-file-side-diff").display = "inline-block";
        }
        else {
            collapseButton.innerText = "Collapse";
        }

        rightDiv.appendChild(collapseButton);
        header.appendChild(rightDiv);
        // header.appendChild(collapseButton);
    });

    // get all .d2h-file-name <a> elements and remove their hrefs and instead scroll to the corresponding diff using the
    // diff id from the href
    const filenameLinks = diffArea.querySelectorAll("a.d2h-file-name")
    filenameLinks.forEach(link => {
        const diffId = link.getAttribute("href").split("#")[1];
        link.setAttribute("data-diff-id", diffId);
        link.removeAttribute("href");
        link.addEventListener("click", () => {
            const diffId = link.getAttribute("data-diff-id");
            const diff = document.getElementById(diffId);
            diff.scrollIntoView();
            // expand the diff if it's collapsed
            if (diff.classList.contains("collapsed")) {
                diff.querySelector(".collapse-button").click();
            }
        });
    });
}

function createOrUpdateDiffViewer() {
    // check if diff viewer already exists
    if (document.querySelector("#diff-viewer")) {
        diffViewer = document.querySelector("#diff-viewer")
    }
    else { // create new diff viewer
        // create new div to hold all diff stuff
        const customDiffArea = document.createElement("div")
        customDiffArea.setAttribute("id", "custom-diff-area")
        // create new div to inject diff viewer into
        const diffViewer = document.createElement("div")
        diffViewer.setAttribute("id", "diff-viewer")
        // create button that will switch between new custom diff viewer and old launchpad diff viewer
        const showOldDiffButton = document.createElement("button");
        showOldDiffButton.classList.add("show-old-diff-button");
        showOldDiffButton.innerText = "Show old diff viewer";
        showOldDiffButton.addEventListener("click", () => {
            // check button's text and toggle between showing old and new diff viewer
            if (showOldDiffButton.innerText === "Show old diff viewer") {
                showOldDiffButton.innerText = "Show new diff viewer";
                document.querySelector(".diff-content").style.display = "";
                diffViewer.style.display = "none";
                showOldDiffButton.classList.remove("showing-new-diff");
                showOldDiffButton.classList.add("showing-old-diff");
            }
            else {
                showOldDiffButton.innerText = "Show old diff viewer";
                document.querySelector(".diff-content").style.display = "none";
                diffViewer.style.display = "";
                showOldDiffButton.classList.remove("showing-old-diff");
                showOldDiffButton.classList.add("showing-new-diff");
            }
        });

        // insert new diff viewer div into customDiffArea
        customDiffArea.appendChild(diffViewer)
        // insert customDiffArea before old diff area that we're replacing
        document.querySelector("#review-diff").insertBefore(showOldDiffButton, document.querySelector(".diff-content"))
        document.querySelector("#review-diff").insertBefore(customDiffArea, document.querySelector(".diff-content"))
        // hide old diff (.diff-content)
        document.querySelector(".diff-content").style.display = "none";
        // document.querySelector(".diff-content").style.height = 0;
        // document.querySelector(".diff-content").style.overflow = "hidden";
    }
    var diff_txt = parseDiffTextFromExistingDiv()
    const diffViewerElement = document.querySelector("#diff-viewer");
    // before clearing the innerHTML, get all collapsed diffs and store their ids
    const collapsedDiffIds = [];
    document.querySelector("#custom-diff-area").querySelectorAll(".d2h-file-wrapper.collapsed").forEach(diff => {
        collapsedDiffIds.push(diff.id);
    });
    diffViewerElement.innerHTML = "";
    diffViewerElement.innerHTML = Diff2Html.html(diff_txt, {
        drawFileList: true,
        matching: 'lines',
        outputFormat: CURRENT_DIFF_VIEW_SETTING, // either "side-by-side" or "unified"
    });

    performDiffViewerMods(collapsedDiffIds);

}

function getHiddenDiffViewerElement(preview_diff_id) {
    return document.querySelector(`#hidden-diff-viewer-${preview_diff_id}`);
}

function createHiddenDiffViewers() {
    console.log("creating hidden diff viewers")
    const preview_diff_ids = get_all_available_preview_diff_ids();
    preview_diff_ids.forEach(preview_diff_id => {
        const diffText = PREVIEW_DIFF_TEXTS[preview_diff_id];
        const diffViewer = document.createElement("div");
        diffViewer.classList.add("hidden-diff-viewer");
        diffViewer.setAttribute("id", `hidden-diff-viewer-${preview_diff_id}`);
        diffViewer.style.display = "none";
        diffViewer.innerHTML = Diff2Html.html(diffText, {
            drawFileList: true,
            matching: 'lines',
            outputFormat: 'unified',
        });
        document.body.appendChild(diffViewer);
    });
}

function addDiffViewSwitcher() {

    if (document.querySelector("#diff-view-switcher")) {
        return;
    }

    const viewSwitcher = document.createElement("button");
    // viewSwitcher.innerText = "View as side-by-side";
    viewSwitcher.innerText = CURRENT_DIFF_VIEW_SETTING === "unified" ? "View as side-by-side" : "View as unified";
    viewSwitcher.setAttribute("id", "diff-view-switcher");
    viewSwitcher.addEventListener("click", () => {
        // const diffViewerElement = document.querySelector("#diff-viewer")
        console.log("view-switcher clicked")
        if (CURRENT_DIFF_VIEW_SETTING === "side-by-side") {
            CURRENT_DIFF_VIEW_SETTING = "unified";  // toggle to unified view
            viewSwitcher.innerText = "View as side-by-side";
        }
        else {
            CURRENT_DIFF_VIEW_SETTING = "side-by-side";  // toggle to side-by-side view
            viewSwitcher.innerText = "View as unified";
        }
        doCustomDiffStuff();
    });

    const customDiffArea = document.querySelector("#custom-diff-area");
    // insert at top of customDiffArea
    customDiffArea.insertBefore(viewSwitcher, customDiffArea.childNodes[0]);

}

function doCustomDiffStuff() {
    // add diff viewer
    createOrUpdateDiffViewer();
    addDiffViewSwitcher();
    // TODO: add local array of unsaved inline draft comments so that when switching between unified and side-by-side
    // views, the comments are "restored" to the correct lines with the correct text
    add_inline_comments_to_custom_diff();
    enable_adding_inline_comments_from_diff();
}

function doCiCdStuff() {
    var cicd_info = replaceCICDComments()
    if (cicd_info.state !== "") {
        createNewCICDElement(cicd_info.state, cicd_info.link)
    }
    else {
        console.log("No CI/CD comments found")
    }
}

// inputs:
// - tr_element (HTML element): the table row element that the comment will be inserted below
// - commentElement (HTML element): the comment element to be inserted
// - line_no (int): the line number that the comment is associated with 
function insertInlineCommentElementBelowLine(tr_element, commentElement, line_no) {
    // check if a comment element already exists for this line
    const existingComment = document.querySelector(`#d2h-inline-comment-line-${line_no}`);
    if (existingComment) {
        console.log("comment already exists for line " + line_no)
        const inlineCommentContainer = existingComment.querySelector(".d2h-inline-comment-container");
        inlineCommentContainer.appendChild(commentElement);
        return;
    }

    const inlineCommentContainer = document.createElement("td");
    inlineCommentContainer.classList.add("d2h-inline-comment-container");
    inlineCommentContainer.setAttribute('colspan', '2');
    inlineCommentContainer.appendChild(commentElement);

    // comment element will be empty for now
    const commentWrapperRow = document.createElement("tr");
    commentWrapperRow.classList.add("d2h-inline-comment-row");
    commentWrapperRow.id = `d2h-inline-comment-line-${line_no}`;
    commentWrapperRow.appendChild(inlineCommentContainer);

    // insert after the tr element
    tr_element.insertAdjacentElement("afterend", commentWrapperRow);
}

// function that updates draft comment state after draft comment is either saved or deleted or posted
function updateDraftCommentState(preview_diff_id, line_number_in_original_diff, action, commentText) {
    const existingDraftComment = getDraftInlineComment(preview_diff_id, line_number_in_original_diff);
    if (action === "save") {
        console.log("adding or updating draft comment in DRAFT_INLINE_COMMENTS array")
        // find the draft comment in the DRAFT_INLINE_COMMENTS array and update its state
        // or if it doesn't exist, add it to the array
        if (existingDraftComment) {
            console.log("updating existing draft comment in DRAFT_INLINE_COMMENTS array")
            console.log("before update:", existingDraftComment);
            DRAFT_INLINE_COMMENTS = DRAFT_INLINE_COMMENTS.filter(comment => comment !== existingDraftComment);
            existingDraftComment.commentText = commentText;
            DRAFT_INLINE_COMMENTS.push(existingDraftComment);
            GROUPED_DRAFT_INLINE_COMMENTS[preview_diff_id][existingDraftComment.file][existingDraftComment.line_no].commentText = commentText;
            console.log("after update:", getDraftInlineComment(preview_diff_id, line_number_in_original_diff));
        }
        else {
            console.log("adding new draft comment to DRAFT_INLINE_COMMENTS array")
            console.log("before add:", DRAFT_INLINE_COMMENTS);
            let basic_inline_comment_map = {}
            basic_inline_comment_map[line_number_in_original_diff] = commentText;
            console.log("basic_inline_comment_map:", basic_inline_comment_map);
            const parsedDraftComment = parseDraftInlineComments(
                preview_diff_id,
                // [{ line_number_in_original_diff: commentText }],
                basic_inline_comment_map
            )[0];
            console.log("parsedDraftComment:", parsedDraftComment);
            DRAFT_INLINE_COMMENTS.push(parsedDraftComment);
            if (!GROUPED_DRAFT_INLINE_COMMENTS[preview_diff_id]) {
                GROUPED_DRAFT_INLINE_COMMENTS[preview_diff_id] = [];
            }
            if (!GROUPED_DRAFT_INLINE_COMMENTS[preview_diff_id][parsedDraftComment.file]) {
                GROUPED_DRAFT_INLINE_COMMENTS[preview_diff_id][parsedDraftComment.file] = [];
            }
            GROUPED_DRAFT_INLINE_COMMENTS[preview_diff_id][parsedDraftComment.file][parsedDraftComment.line_no] = parsedDraftComment;
            console.log("after add:", getDraftInlineComment(
                preview_diff_id,
                line_number_in_original_diff,
            ), DRAFT_INLINE_COMMENTS);
        }
    }
    else if (action === "post" || action === "delete") {
        console.log("removing draft comment from DRAFT_INLINE_COMMENTS array")
        // remove the draft comment from the DRAFT_INLINE_COMMENTS array
        DRAFT_INLINE_COMMENTS = DRAFT_INLINE_COMMENTS.filter(comment => comment !== existingDraftComment);
        // remove the draft comment from the GROUPED_DRAFT_INLINE_COMMENTS object
        delete GROUPED_DRAFT_INLINE_COMMENTS[preview_diff_id][existingDraftComment.file][existingDraftComment.line_no];
    }
}


/**
 * 
 * @param {function(number, string): Promise<boolean>} cancelCommentCallback - 
 *   Async function to cancel a comment, takes in `line_no` and `preview_diff_id`.
 * @param {function(number, string, string): Promise<boolean>} postCommentCallback - 
 *   Async function to post a comment, takes in `line_no`, `preview_diff_id`, and `commentText`.
 * @param {function(number, string, string): Promise<boolean>} saveDraftCommentCallback - 
 *   Async function to save a draft comment, takes in `line_no`, `preview_diff_id`, and `commentText`.
 * @param {function(number, string): Promise<boolean>} deleteCommentCallback - 
 *   Async function to delete a comment, takes in `line_no` and `preview_diff_id`.
 * @param {number} line_number_in_original_diff - The line number specific to the original diff.
 * @param {string} preview_diff_id - The preview diff ID associated with the comment.
 * @param {string} initial_comment_text - The text to pre-fill in the comment textarea.
 * @returns 
 */
function createEditableCommentElement(
    cancelCommentCallback,
    postCommentCallback,
    saveDraftCommentCallback,
    deleteCommentCallback,
    line_number_in_original_diff,
    preview_diff_id,
    initial_comment_text,
) {

    // const header = document.createElement("div");
    // header.classList.add("d2h-inline-comment-header");
    // header.innerText = "Add inline comment:"
    console.log("creating editable comment element for line", line_number_in_original_diff, "in preview diff", preview_diff_id, "with initial comment text:", initial_comment_text);
    const textarea = document.createElement("textarea");
    textarea.classList.add("d2h-inline-comment-textarea");
    textarea.setAttribute("placeholder", "Enter comment...");
    textarea.value = initial_comment_text || "";

    // add javascript function that will expand the textarea as the user types vertically
    // using the textarea's scrollHeight property
    textarea.addEventListener("input", function () {
        textarea.style.height = 'auto'; // Reset the height
        const target_height = textarea.scrollHeight;
        textarea.style.height = target_height + "px";
    });


    const footer = document.createElement("div");

    footer.classList.add("d2h-inline-comment-footer");

    const tabs = document.createElement("div");
    tabs.classList.add("d2h-inline-comment-tabs");
    const edit_comment_button = document.createElement("button");
    edit_comment_button.innerText = "Edit Comment";
    edit_comment_button.classList.add("d2h-inline-comment-tab");
    edit_comment_button.classList.add("edit-comment");
    edit_comment_button.classList.add("active");
    const preview_comment_button = document.createElement("button");
    preview_comment_button.innerText = "Preview Comment";
    preview_comment_button.classList.add("d2h-inline-comment-tab");
    preview_comment_button.classList.add("preview-comment");
    tabs.appendChild(edit_comment_button);
    tabs.appendChild(preview_comment_button);

    const preview = document.createElement("div");
    preview.classList.add("d2h-inline-comment-preview");
    preview.classList.add("markdown")
    preview.style.display = "none";

    const contentArea = document.createElement("div");
    contentArea.classList.add("d2h-inline-comment-content-area");
    contentArea.appendChild(textarea);
    contentArea.appendChild(preview);

    edit_comment_button.addEventListener("click", () => {
        edit_comment_button.classList.add("active");
        preview_comment_button.classList.remove("active");
        textarea.style.display = "block";
        preview.style.display = "none";
    });
    preview_comment_button.addEventListener("click", () => {
        preview_comment_button.classList.add("active");
        edit_comment_button.classList.remove("active");
        preview.style.display = "block";
        textarea.style.display = "none";
        if (textarea.value.trim() === "") {
            preview.innerHTML = "<p>Nothing to preview</p>";
        } else {
            preview.innerHTML = MDconverter.makeHtml(textarea.value);
        }

    });

    const inlineCommentCard = document.createElement("div");
    inlineCommentCard.classList.add("d2h-inline-comment-card");

    const editableInlineComment = document.createElement("div");
    editableInlineComment.setAttribute("preview_diff_id", preview_diff_id);
    editableInlineComment.setAttribute("line_number_in_original_diff", line_number_in_original_diff);
    inlineCommentCard.appendChild(editableInlineComment);

    function deleteAndCleanupParentIfNecessary() {
        // if editableInlineComment is in a row by itself and not part of a thread of comments, remove the row
        // TODO: maybe convert to use closest() to find the parent row element to make this more robust
        if (inlineCommentCard && inlineCommentCard.parentElement.parentElement.classList?.contains("d2h-inline-comment-row")) {
            console.log("removing parent row")
            inlineCommentCard.parentElement.parentElement.remove();
        }
        inlineCommentCard.remove();
    }

    // save draft button
    const saveDraftButton = document.createElement("button");
    if (saveDraftCommentCallback !== null) {
        saveDraftButton.innerText = "Save Draft";
        saveDraftButton.classList.add("d2h-inline-comment-button");
        saveDraftButton.classList.add("save-draft");
        saveDraftButton.addEventListener("click", async () => {
            // disable the save draft button and show the custom-button-spinner
            const btn_text = saveDraftButton.innerText;
            saveDraftButton.innerText = " ";
            saveDraftButton.classList.add("disabled", "custom-button-spinner");
            // TODO: saving new comment (one that hasn't been saved before) as a draft doesn't seem to update the save
            // button properly. it should be disabled until the text in the textarea changes from the saved draft text
            // this might be due to the fact that the draft comment is not being added to the DRAFT_INLINE_COMMENTS array
            // needs further investigation
            try {
                // disable the save draft button while the comment is being saved
                saveDraftButton.classList.add("disabled");
                // call the saveDraftCommentCallback function
                const success = await saveDraftCommentCallback(line_number_in_original_diff, preview_diff_id, textarea.value);
                if (!success) {
                    console.log("got failure back from saveDraftCommentCallback")
                    saveDraftButton.classList.remove("disabled");
                    return;
                }
                else {
                    console.log("got success back from saveDraftCommentCallback")
                }

                updateDraftCommentState(
                    preview_diff_id,
                    line_number_in_original_diff,
                    "save",
                    textarea.value,
                )

            } catch (error) {
                console.error("An error occurred:", error);
            }
            finally {
                // always remove the custom-button-spinner and re-enable the button
                saveDraftButton.classList.remove("disabled", "custom-button-spinner");
                saveDraftButton.innerText = btn_text;
                updateButtons();
            }
        });
    }
    else {
        saveDraftButton.display = "none";
    }

    // post comment button
    const postButton = document.createElement("button");
    postButton.innerText = "Post Comment";
    postButton.classList.add("d2h-inline-comment-button");
    postButton.classList.add("post-comment");

    postButton.addEventListener("click", async () => {
        // Disable the post button and show the custom-button-spinner
        const btn_text = postButton.innerText;
        postButton.innerText = " ";
        postButton.classList.add("disabled", "custom-button-spinner");

        try {
            const success = await postCommentCallback(line_number_in_original_diff, preview_diff_id, textarea.value);
            if (!success) {
                console.log("got failure back from postCommentCallback")
                return;
            }
            deleteAndCleanupParentIfNecessary();
        } catch (error) {
            console.error("An error occurred:", error);
        } finally {
            // Always remove the custom-button-spinner and re-enable the button
            postButton.classList.remove("disabled", "custom-button-spinner");
            postButton.innerText = btn_text;
        }
    });

    // cancel comment button
    const cancelButton = document.createElement("button");
    // cancelButton.innerText = getDraftInlineComment(preview_diff_id, line_number_in_original_diff) ? "Discard Changes"
    // : "Delete Draft";

    function updateButtons() {
        // TODO: add text to editable comment that says "no unsaved changes" or "unsaved changes" based on whether the
        // text in the textarea is different from the saved draft to let the user know if they have unsaved changes
        // if this comment has already been saved as a draft AND the text in the textarea is different from the saved draft
        // text
        const draftCommentElement = getDraftInlineComment(preview_diff_id, line_number_in_original_diff);
        if (draftCommentElement && draftCommentElement.commentText !== textarea.value) {
            console.log("modified existing draft comment")
            cancelButton.innerText = "Discard Changes";
            cancelButton.classList.remove("cancel-comment");
            cancelButton.classList.remove("delete-draft");
            cancelButton.classList.add("discard-changes");
            saveDraftButton.classList.remove("disabled");
            postButton.classList.remove("disabled");
        }
        // if this comment was just created and the textarea is empty
        else if (!draftCommentElement && textarea.value === "") {
            console.log("new comment and textarea is empty")
            cancelButton.innerText = "Cancel";
            cancelButton.classList.remove("delete-draft");
            cancelButton.classList.remove("discard-changes");
            cancelButton.classList.add("cancel-comment");
            saveDraftButton.classList.add("disabled");
            postButton.classList.add("disabled");
        }
        // if this comment was just created and the textarea is not empty
        else if (!draftCommentElement && textarea.value !== "") {
            console.log("new comment and textarea is not empty")
            postButton.classList.remove("disabled");
            saveDraftButton.classList.remove("disabled");
            cancelButton.innerText = "Cancel";
            cancelButton.classList.remove("delete-draft");
            cancelButton.classList.remove("discard-changes");
            cancelButton.classList.add("cancel-comment");
        }
        else {
            console.log("unmodified existing draft comment")
            cancelButton.innerText = "Delete";
            cancelButton.classList.remove("cancel-comment");
            cancelButton.classList.remove("discard-changes");
            cancelButton.classList.add("delete-draft");
            saveDraftButton.classList.add("disabled");
            postButton.classList.remove("disabled");
        }
    }
    updateButtons();
    // add event listener to update the cancel button text when the textarea value changes
    textarea.addEventListener("input", updateButtons);
    cancelButton.classList.add("d2h-inline-comment-button");
    cancelButton.addEventListener("click", async () => {
        // disable the cancel button and show the custom-button-spinner
        const btn_text = cancelButton.innerText;
        cancelButton.innerText = " ";
        cancelButton.classList.add("disabled", "custom-button-spinner");
        try {
            // delete draft
            if (cancelButton.classList.contains("delete-draft")) {
                // send alert to confirm deletion of draft
                if (!confirm("Are you sure you want to delete this draft? This text will be lost.")) {
                    return;
                }
                // disable the cancel button while the comment is being deleted
                cancelButton.classList.add("disabled");
                const success = await deleteCommentCallback(line_number_in_original_diff, preview_diff_id);
                if (!success) {
                    console.log("got failure back from deleteCommentCallback")
                    cancelButton.classList.remove("disabled");
                    return;
                }
                deleteAndCleanupParentIfNecessary();
            }
            // cancel comment
            else if (cancelButton.classList.contains("cancel-comment")) {
                // no need for success checking here since we're just cancelling and this requires no server interaction
                await cancelCommentCallback(line_number_in_original_diff, preview_diff_id);
                deleteAndCleanupParentIfNecessary();
            }
            else {  // "DISCARD CHANGES"
                // send alert to confirm discarding changes
                if (!confirm("Are you sure you want to discard your unsaved changes?")) {
                    return;
                }
                // restore the original comment text
                textarea.value = getDraftInlineComment(preview_diff_id, line_number_in_original_diff).commentText;
            }
        } catch (error) {
            console.error("An error occurred:", error);
        } finally {
            // always remove the custom-button-spinner and re-enable the button
            cancelButton.classList.remove("disabled", "custom-button-spinner");
            cancelButton.innerText = btn_text;
            updateButtons();
        }
    });
    footer.appendChild(saveDraftButton);
    footer.appendChild(postButton);
    footer.appendChild(cancelButton);


    editableInlineComment.classList.add("d2h-editable-inline-comment");
    editableInlineComment.classList.add("d2h-inline-comment");
    // make the editable text wrap instead of extending horizontally
    editableInlineComment.style.whiteSpace = "pre-wrap";

    // editableInlineComment.appendChild(header);
    editableInlineComment.appendChild(tabs);
    // editableInlineComment.appendChild(textarea);
    // editableInlineComment.appendChild(preview);
    editableInlineComment.appendChild(contentArea);
    editableInlineComment.appendChild(footer);

    // return as list even though it's only one element
    // this will allow for comment threads in the future
    return inlineCommentCard;
}

// function to return x number of lines before the target line number
// and y number of lines after the target line number including the target line
function getLinesAroundTargetLine(preview_diff_id, fileName, lineNumber, numberOfLinesBefore, numberOfLinesAfter) {
    const hiddenDiffElement = findHiddenDiffElementByFileName(fileName, preview_diff_id);
    const lines = hiddenDiffElement.querySelectorAll("tr");
    var targetLineIndex = -1;
    lines.forEach((line, index) => {
        if (parseInt(line.querySelector(".d2h-code-linenumber").innerText) === lineNumber) {
            targetLineIndex = index;
        }
    });
    if (targetLineIndex === -1) {
        console.log(`target line ${lineNumber} not found in file ${fileName}`);
        return null;
    }
    const linesArray = Array.from(lines);
    const linesBefore = linesArray.slice(Math.max(0, targetLineIndex - numberOfLinesBefore), targetLineIndex);
    const targetLine = linesArray[targetLineIndex];
    const linesAfter = linesArray.slice(targetLineIndex + 1, targetLineIndex + numberOfLinesAfter + 1);
    // combine the before and after lines and the target line into one list and return that
    console.log(`returning ${linesBefore.concat(targetLine).concat(linesAfter).length} lines around line ${lineNumber} in file ${fileName}`);
    return linesBefore.concat(targetLine).concat(linesAfter);
}

function createInlineCommentElement(commentInfo) {
    // console.log("creating inline comment element for comment: " + commentInfo.commentText)
    const header = document.createElement("div");
    header.classList.add("d2h-inline-comment-header");

    const mugshot_image = document.createElement("img");
    mugshot_image.classList.add("d2h-inline-comment-mugshot");
    // console.log(commentInfo.author.local_mugshot_url)
    mugshot_image.src = commentInfo.author.local_mugshot_url || "https://www.clipartmax.com/png/small/34-340027_user-login-man-human-body-mobile-person-comments-person-icon-png.png";
    mugshot_image.alt = `${commentInfo.author.display_name} (${commentInfo.author.name}) mugshot`;
    header.appendChild(mugshot_image);

    const author_element = document.createElement("span");
    author_element.classList.add("d2h-inline-comment-author");
    author_element.innerText = `${commentInfo.author.display_name} (${commentInfo.author.name})`;
    header.appendChild(author_element);

    const date_element = document.createElement("span");
    // convert raw datetime (2024-03-11T16:32:09.664021+00:00) to human-readable format in local timezone
    const commentDate = new Date(commentInfo.commentDate).toLocaleString();
    date_element.classList.add("d2h-inline-comment-date");
    date_element.innerText = ` on ${commentDate}`;
    header.appendChild(date_element);



    const body = document.createElement("div");
    body.classList.add("d2h-inline-comment-body");
    body.classList.add("markdown");

    body.innerHTML = MDconverter.makeHtml(commentInfo.commentText);

    const customCommentElement = document.createElement("div");
    customCommentElement.classList.add("d2h-inline-comment");
    // commentElement.setAttribute("contenteditable", "true");
    // commentElement.setAttribute("placeholder", "Enter comment...");
    // make the editable text wrap instead of extending horizontally
    // customCommentElement.style.whiteSpace = "pre-wrap";

    customCommentElement.appendChild(header);
    customCommentElement.appendChild(body);

    // return as list even though it's only one element
    // this will allow for comment threads in the future
    return customCommentElement;

}

function extractFileAndLineFromDiff(lineNumber, diffTxt) {
    // if lineNumber is a string, convert it to an integer
    lineNumber = parseInt(lineNumber);

    // Split the diff into lines
    const lines = diffTxt.split("\n");

    let currentFile = null;
    let currentLineNumberInFile = 0;
    let addedLines = 0; // Track the number of lines added in the diff
    let removedLines = 0; // Track the number of lines removed in the diff

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Detect a file path in the diff
        if (line.startsWith("+++ ")) {
            currentFile = line.split(" ")[1].slice(2);
        } else if (line.startsWith("@@")) {
            // Parse chunk header to get starting line number in the file
            const chunkInfo = line.split("@@")[1];
            currentLineNumberInFile = parseInt(chunkInfo.split(" ")[2].split(",")[0]);

            // Reset added and removed line counters for each new chunk
            addedLines = 0;
            removedLines = 0;

            // Adjust line number for chunks starting from 0 (new files)
            if (currentLineNumberInFile === 0) {
                currentLineNumberInFile = 1;
            }
            continue;
        }

        // If the current line number in the diff matches the provided line number
        if (i + 1 === lineNumber) {
            return [currentFile, currentLineNumberInFile + addedLines - removedLines, line];
        }

        // Adjust line count based on whether lines are added, removed, or unchanged
        if (line.startsWith("+")) {
            addedLines++;
        } else if (line.startsWith("-")) {
            removedLines++;
        } else {
            // This accounts for unchanged lines which should also increase the current line number in file
            currentLineNumberInFile++;
        }
    }

    // If the line number was not found in the diff
    return [null, null, null];
}
function findLineNumberInDiff(fileName, lineNumberInFile, diffTxt) {
    /**
     * Given a file name, a line number within that file (new file),
     * and the diff text, return the line number in the diff where that line is located.
     *
     * Note: Line numbers in the diff start from 1 (first line is line 1).
     *
     * Args:
     *     fileName (string): The name of the file (relative path).
     *     lineNumberInFile (number): The line number within the new file.
     *     diffTxt (string): The diff text.
     *
     * Returns:
     *     number|null: The line number in the diff where the line is located, or null if not found.
     */
    const lines = diffTxt.split('\n');
    let currentFile = null;
    let diffLineNumber = 0;

    let i = 0;
    while (i < lines.length) {
        const line = lines[i];
        diffLineNumber += 1; // Increment diff line number

        // Detect a file path in the diff
        if (line.startsWith('+++ ')) {
            currentFile = line.split(' ')[1].slice(2); // Remove 'b/' prefix
            i += 1;
            continue;
        }

        if (currentFile !== fileName) {
            i += 1;
            continue;
        }

        // Process chunks for the current file
        if (line.startsWith('@@')) {
            // Parse chunk header
            const m = line.match(/^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/);
            if (m) {
                let newFileLine = parseInt(m[1], 10);
                let fileLineNumber = newFileLine - 1; // Starting line number in the new file
                i += 1;
                diffLineNumber += 1; // Account for the '@@' line
                while (
                    i < lines.length &&
                    !lines[i].startsWith('@@') &&
                    !lines[i].startsWith('diff --git') &&
                    !lines[i].startsWith('--- ') &&
                    !lines[i].startsWith('+++ ')
                ) {
                    const diffLine = lines[i];
                    const firstChar = diffLine ? diffLine[0] : '';
                    // Ignore special lines
                    if (diffLine === '\\ No newline at end of file') {
                        i += 1;
                        diffLineNumber += 1;
                        continue;
                    }
                    if (firstChar === ' ' || firstChar === '+') {
                        fileLineNumber += 1;
                        if (fileLineNumber === lineNumberInFile) {
                            return diffLineNumber;
                        }
                    }
                    // For removed lines ('-'), do not increment fileLineNumber
                    // but still increment diffLineNumber
                    i += 1;
                    diffLineNumber += 1;
                }
                continue;
            } else {
                i += 1;
                continue;
            }
        } else {
            i += 1;
        }
    }
    // If the line number was not found in the diff
    return null;
}

// async function fetchAllMugshots() {
//     const allAuthors = Array.from(new Set(INLINE_COMMENTS.map(comment => comment.author)));
//     const allAuthorMugshotUrls = new Set(allAuthors.map(author => author.mugshot_link));

//     // Create an array of promises, one for each mugshot URL
//     const fetchPromises = Array.from(allAuthorMugshotUrls).map(mugshotUrl =>
//         fetch(mugshotUrl)
//             .then(response => response.blob())
//             .then(blob => {
//                 // console.log(`Fetched mugshot blob for ${mugshotUrl}:`, blob);
//                 // Check if the fetched blob is an image
//                 if (blob.type.startsWith("image")) {
//                     const url = URL.createObjectURL(blob);
//                     // console.log("Created object URL:", url);
//                     // Add the mugshot URL to the MUGSHOT_URLS map
//                     MUGSHOT_URLS[mugshotUrl] = url;
//                 }
//             })
//     );

//     // Return a Promise that resolves when all fetch operations are complete
//     return Promise.all(fetchPromises);
// }

// given a mugshot url, fetch the image and return a local url
// and store the local url in the MUGSHOT_URLS map for future use
// if the image is already fetched, return the local url from the MUGSHOT_URLS map
// TODO: Caching doesnt work properly when mugshot is requested asychronously by parallel requests
async function getLocalMugshotUrl(mugshotUrl) {
    console.log("getting local mugshot url for:", mugshotUrl);
    console.log("MUGSHOT_URLS:", MUGSHOT_URLS);
    if (mugshotUrl in MUGSHOT_URLS) {
        return MUGSHOT_URLS[mugshotUrl];
    }

    try {
        const response = await fetch(mugshotUrl);
        const blob = await response.blob();
        // console.log(`Fetched mugshot blob for ${mugshotUrl}:`, blob);

        // Check if the fetched blob is an image
        if (blob.type.startsWith("image")) {
            const url = URL.createObjectURL(blob);
            // console.log("Created object URL:", url);
            // Add the mugshot URL to the MUGSHOT_URLS map
            MUGSHOT_URLS[mugshotUrl] = url;
            return url;
        } else {
            MUGSHOT_URLS[mugshotUrl] = null;
            console.error("mugshot URL does not point to an image:", mugshotUrl);
            return null;
        }
    } catch (error) {
        console.error(`Error fetching mugshot for ${mugshotUrl}:`, error);
        return null;
    }
}

/**
 * 
 * must be called AFTER fetching diff texts and mugshots
 * 
 * @param {*} apiResponse : list of inline comment objects from the API
 * @param {*} preview_diff_id : the preview diff id that the comments are associated with
 */
async function parseInlineCommentsFromAPIResponse(apiResponse, preview_diff_id) {

    let parsedComments = [];

    console.log(`parsing ${apiResponse.length} inline comments from API response`);

    function parsePersonObject(personObject) {
        return {
            name: personObject.name,
            display_name: personObject.display_name,
            description: personObject.description,
            web_link: personObject.web_link,
            self_link: personObject.self_link,
            logo_link: personObject.logo_link,
            mugshot_link: personObject.mugshot_link,
        };
    }

    // after the diff text has been selected or fetched, parse the comments
    for (const comment of apiResponse) {
        [file, line_no, lineContent] = extractFileAndLineFromDiff(
            comment.line_number,
            PREVIEW_DIFF_TEXTS[preview_diff_id],
        );
        const new_parsed_comment = {
            line_number_in_original_diff: comment.line_number,
            author: parsePersonObject(comment.person),
            commentText: comment.text,
            commentDate: comment.date,
            file: file,
            line_no: line_no,
            lineContent: lineContent,
            preview_diff_id: preview_diff_id,
        };
        // use getLocalMugshotUrl to set the local_mugshot_url property
        new_parsed_comment.author.local_mugshot_url = await getLocalMugshotUrl(comment.person.mugshot_link);
        parsedComments.push(new_parsed_comment);
    }

    console.log("parsed inline comments from API response:", parsedComments);
    return parsedComments;
}

async function fetchDiffTextFromMicroservice(preview_diff_id) {

    const url = MICROSERVICE_BASE_URL + "/preview_diff/text"
    
    // pass preview_diff_id and mp_url as query parameters
    const params = {
        preview_diff_id: preview_diff_id,
        mp_url: document.location.href,
    };
    // we are sending url encoded data and recieving text
    const urlParams = new URLSearchParams(params).toString();
    const url_with_params = url + "?" + urlParams;

    try {
        const response = await fetch(url_with_params, {
            method: "GET",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
            },         
        });

        if (!response.ok) {
            console.error(`Error fetching diff text from API for preview diff ${preview_diff_id}:`, response);
            return ""; // Return empty string on error to avoid breaking downstream logic
        }
        const data = await response.text();
        console.log(`fetched diff text from API for preview diff ${preview_diff_id}`);
        return data;
    }
    catch (error) {
        console.error('Error fetching diff text from API:', error);
        return ""; // Return empty string on error to avoid breaking downstream logic
    }
}
async function fetchAllPreviewDiffTexts() {
    const startTime = performance.now();
    const all_preview_diff_ids = get_all_available_preview_diff_ids();

    // Create an array of promises, one for each preview diff ID
    const fetchPromises = all_preview_diff_ids.map(preview_diff_id =>
        fetchDiffTextFromMicroservice(preview_diff_id).then(diffText => {
            PREVIEW_DIFF_TEXTS[preview_diff_id] = diffText;
        })
    );

    // Return a Promise that resolves when all fetch operations are complete
    return Promise.all(fetchPromises).then(() => {
        const endTime = performance.now();
        console.log(`it took ${endTime - startTime} milliseconds to fetch all diff texts`);
    });
}

/**
 * 
 * @param {*} preview_diff_id : the preview diff to fetch inline comments for
 * @returns list of parsed inline comments
 */
async function fetch_inline_comments_from_api(preview_diff_id) {
    try {
        const mpUrl = document.location.href;
        const api_url = convertMPUrlToAPIUrl(mpUrl);

        const inline_comment_query_url = `${api_url}?ws.op=getInlineComments&previewdiff_id=${preview_diff_id}`;

        const response = await fetch(inline_comment_query_url, {
            method: "GET",
            headers: {
                "Content-Type": "application/json"
            }
        });

        const data = await response.json();
        console.log(data);

        return parseInlineCommentsFromAPIResponse(data, preview_diff_id);

    } catch (error) {
        console.error('Error fetching inline comments from api:', error);
        return []; // Return an empty array to prevent issues downstream
    }
}

/**
 * 
 * @param {*} preview_diff_id : preview_diff_id the draft comments are associated with
 * @param {*} draftComments : draft comments JSON object in the format {LINE_NUMBER: COMMENT_TEXT, ...}
 * @returns 
 */
function parseDraftInlineComments(preview_diff_id, draftComments) {
    console.log("parsing draft inline comments:", draftComments);
    let parsedDraftComments = [];
    for (const line_number_in_original_diff in draftComments) {
        const commentText = draftComments[line_number_in_original_diff];
        [file, line_no, lineContent] = extractFileAndLineFromDiff(
            line_number_in_original_diff,
            PREVIEW_DIFF_TEXTS[preview_diff_id],
        );
        parsedDraftComments.push({
            line_number_in_original_diff: parseInt(line_number_in_original_diff),
            file: file,
            line_no: line_no,
            lineContent: lineContent,
            commentText: commentText,
            preview_diff_id: preview_diff_id,
        });
    }
    return parsedDraftComments;
}

async function fetch_draft_inline_comments_from_api(preview_diff_id) {
    try {
        const mpUrl = document.location.href;
        const api_url = convertMPUrlToAPIUrl(mpUrl);

        // f"{mp_url}?ws.op=getDraftInlineComments&previewdiff_id={preview_diff_id}"
        const inline_comment_query_url = `${api_url}?ws.op=getDraftInlineComments&previewdiff_id=${preview_diff_id}`;

        const response = await fetch(inline_comment_query_url, {
            method: "GET",
            headers: {
                "Content-Type": "application/json"
            }
        });

        const data = await response.json();
        console.log("fetched draft inline comments from API:", data);

        // data will be in format [{LINE_NUMBER: COMMENT_TEXT}, ...]
        // parse the data similar to how we parse the inline comments
        return parseDraftInlineComments(preview_diff_id, data);

    } catch (error) {
        console.error('Error fetching draft inline comments from api:', error);
        return []; // Return an empty array to prevent issues downstream
    }
}

async function fetchInlineCommentsAndAddToCustomDiff() {

    const all_preview_diff_ids = get_all_available_preview_diff_ids();

    // // fetch all mugshots
    // console.log("fetching all mugshots");
    // await fetchAllMugshots();
    // console.log("fetched all mugshots");

    // TODO: fetch all diff texts in parallel with mugshots
    // TODO: THEN once all diff texts and mugshots are fetched, fetch inline comments and draft inline comments in
    // parallel
    console.log("Starting to fetch all inline comments and draft inline comments");
    const startTime = performance.now();

    for (const preview_diff_id of all_preview_diff_ids) {
        try {
            const inline_comments = await fetch_inline_comments_from_api(preview_diff_id);
            console.log(`found ${inline_comments.length} inline comments for preview diff ${preview_diff_id}`);
            INLINE_COMMENTS = INLINE_COMMENTS.concat(inline_comments);
            console.log("INLINE_COMMENTS:", INLINE_COMMENTS);
            const draft_comments = await fetch_draft_inline_comments_from_api(preview_diff_id);
            console.log(`found ${draft_comments.length} draft inline comments for preview diff ${preview_diff_id}`);
            DRAFT_INLINE_COMMENTS = DRAFT_INLINE_COMMENTS.concat(draft_comments);
            console.log("DRAFT_INLINE_COMMENTS:", DRAFT_INLINE_COMMENTS);
        } catch (error) {
            console.error(`Failed to fetch inline comments for preview diff ${preview_diff_id}:`, error);
        }
    }

    const endTime = performance.now();
    console.log(`Finished fetching all inline comments and draft inline comments in ${endTime - startTime} milliseconds`);

    // group comments by preview_diff_id, file, and line number
    // for each preview_diff_id, for each file, for each line number, create a list of comments
    INLINE_COMMENTS.forEach(inline_comment => {
        // Check if the preview_diff_id exists in the grouped comments
        if (!(inline_comment.preview_diff_id in GROUPED_INLINE_COMMENTS)) {
            GROUPED_INLINE_COMMENTS[inline_comment.preview_diff_id] = {};
        }

        // Check if the file exists for the specific preview_diff_id
        if (!(inline_comment.file in GROUPED_INLINE_COMMENTS[inline_comment.preview_diff_id])) {
            GROUPED_INLINE_COMMENTS[inline_comment.preview_diff_id][inline_comment.file] = {};
        }

        // Check if the line number exists for the specific file
        if (!(inline_comment.line_no in GROUPED_INLINE_COMMENTS[inline_comment.preview_diff_id][inline_comment.file])) {
            GROUPED_INLINE_COMMENTS[inline_comment.preview_diff_id][inline_comment.file][inline_comment.line_no] = [];
        }

        // Add the parsed comment to the appropriate group
        GROUPED_INLINE_COMMENTS[inline_comment.preview_diff_id][inline_comment.file][inline_comment.line_no].push(inline_comment);
    });

    // group draft comments by preview_diff_id, file, and line number
    // for each preview_diff_id, for each file, for each line number, create a list of draft comments
    // unlike for inline comments, there will only ever be one draft comment per line
    DRAFT_INLINE_COMMENTS.forEach(draft_comment => {
        // Check if the preview_diff_id exists in the grouped comments
        if (!(draft_comment.preview_diff_id in GROUPED_DRAFT_INLINE_COMMENTS)) {
            GROUPED_DRAFT_INLINE_COMMENTS[draft_comment.preview_diff_id] = {};
        }

        // Check if the file exists for the specific preview_diff_id
        if (!(draft_comment.file in GROUPED_DRAFT_INLINE_COMMENTS[draft_comment.preview_diff_id])) {
            GROUPED_DRAFT_INLINE_COMMENTS[draft_comment.preview_diff_id][draft_comment.file] = {};
        }

        // set the draft comment for the specific line number
        GROUPED_DRAFT_INLINE_COMMENTS[draft_comment.preview_diff_id][draft_comment.file][draft_comment.line_no] = draft_comment;
    });


    console.log("grouped inline comments", GROUPED_INLINE_COMMENTS)

    // TODO: also pass in the draft comments
    createCodeCommentCards(GROUPED_INLINE_COMMENTS, GROUPED_DRAFT_INLINE_COMMENTS);

    add_inline_comments_to_custom_diff();

}


function createCommentThreadElement(comments, draftComment, inDiffViewer) {
    /**
     * Comment thread will contain the following elements:
     * inline comment elements following one another
     * an optional draft comment element that will be represented as an editable comment element with the draft comment text pre-filled
     * Reply button that when clicked will hide itself and replace itself with a editable comment element
     * 
     * this function will use createInlineCommentElement to create the inline comment elements
     */
    const commentThread = document.createElement("div");
    commentThread.classList.add("d2h-inline-comment-thread");
    comments.forEach(comment => {
        commentThread.appendChild(createInlineCommentElement(comment));
    });

    const replyButton = document.createElement("button");
    replyButton.classList.add("d2h-inline-comment-reply-button");
    replyButton.innerText = "Reply";

    async function deleteCommentCallback(line_no, preview_diff_id) {
        // cancel comment callback
        const success = await deleteInlineComment(line_no, preview_diff_id);
        if (success) {
            // show the reply button again
            replyButton.style.display = "block";
        }
        return success;
    }

    async function saveDraftCommentCallback(line_no, preview_diff_id, commentText) {
        // save draft comment callback
        const success = await saveDraftInlineComment(line_no, preview_diff_id, commentText);
        if (success) {
            // show the reply button again
            replyButton.style.display = "block";
        }
        return success;
    }

    async function postInlineCommentCallback(line_no, preview_diff_id, commentText) {
        // post comment callback
        const success = await postInlineComment(line_no, preview_diff_id, commentText);
        if (success) {
            // show the reply button again
            replyButton.style.display = "block";
        }
        return success;
    }

    async function cancelCommentCallback(line_no, preview_diff_id) {
        // show the reply button again
        replyButton.style.display = "block";
        return true;
    }

    replyButton.addEventListener("click", () => {
        console.log("is in diff viewer:", inDiffViewer);
        // only execute if the reply button is visible
        if (replyButton.style.display !== "none") {
            replyButton.style.display = "none";
            const editableComment = createEditableCommentElement(
                cancelCommentCallback,
                postInlineCommentCallback,
                inDiffViewer ? saveDraftCommentCallback : null,
                deleteCommentCallback,
                comments[0].line_number_in_original_diff,  // line_number_in_original_diff
                comments[0].preview_diff_id,  // preview_diff_id
                null, // initial comment text
            );

            commentThread.appendChild(editableComment);
        }
    });

    commentThread.appendChild(replyButton);

    if (draftComment) {
        // hide the reply button since there is already an editable comment
        replyButton.style.display = "none";
        // now create the editable comment element using the draft comment 
        const draftCommentElement = createEditableCommentElement(
            cancelCommentCallback,
            postInlineCommentCallback,
            inDiffViewer ? saveDraftCommentCallback : null,
            deleteCommentCallback,
            draftComment.line_number_in_original_diff,
            draftComment.preview_diff_id,
            draftComment.commentText,
        );
        commentThread.appendChild(draftCommentElement);
    }

    return commentThread;
}

function add_inline_comments_to_custom_diff() {
    // TODO: in side by side mode, insert element into opposite side that listens for height changes and adjusts
    // the height of the corresponding element in the other side so that lines on both sides are aligned
    console.log("adding inline comments to custom diff");
    const file_diffs = document.querySelector("#custom-diff-area").querySelectorAll(".d2h-file-wrapper");
    const current_preview_diff_id = get_currently_selected_preview_diff_id();

    // Check if there are any comments (either inline or draft) for the current preview diff.
    const hasInlineComments = current_preview_diff_id in GROUPED_INLINE_COMMENTS;
    const hasDraftComments = current_preview_diff_id in GROUPED_DRAFT_INLINE_COMMENTS;

    if (!hasInlineComments && !hasDraftComments) return; // Exit if no comments exist.

    // Loop through files that have either inline or draft comments.
    const files = new Set([
        ...Object.keys(GROUPED_INLINE_COMMENTS[current_preview_diff_id] || {}),
        ...Object.keys(GROUPED_DRAFT_INLINE_COMMENTS[current_preview_diff_id] || {})
    ]);

    files.forEach(file => {
        const lines = new Set([
            ...Object.keys(GROUPED_INLINE_COMMENTS[current_preview_diff_id]?.[file] || {}),
            ...Object.keys(GROUPED_DRAFT_INLINE_COMMENTS[current_preview_diff_id]?.[file] || {})
        ]);

        lines.forEach(line_no => {
            const comments = GROUPED_INLINE_COMMENTS[current_preview_diff_id]?.[file]?.[line_no] || [];
            const draftComment = GROUPED_DRAFT_INLINE_COMMENTS[current_preview_diff_id]?.[file]?.[line_no] || null;

            // Find the matching file diff element.
            file_diffs.forEach(file_diff => {
                const file_name = get_file_name_from_diff_element(file_diff);
                if (file_name === file) {
                    let gutters = null;
                    // unified view
                    if (CURRENT_DIFF_VIEW_SETTING === "unified") {
                        gutters = file_diff.querySelectorAll(".d2h-code-linenumber");
                    }
                    // side-by-side view
                    else {
                        // for side-by-side view, the file_diff element is called ".d2h-files-diff" instead of
                        // ".d2h-file-diff" and will have 2 children
                        const new_side = file_diff.querySelector(".d2h-files-diff").children[1];
                        gutters = new_side.querySelectorAll(".d2h-code-side-linenumber");
                    }
                    // Find the gutter corresponding to the line number.
                    let target_gutter = null;
                    gutters.forEach(element => {
                        if (parseInt(element.innerText) === parseInt(line_no)) {
                            target_gutter = element;
                        }
                    });

                    if (target_gutter) {
                        if (comments.length > 0) {
                            // Insert comment thread if inline comments exist.
                            const commentThreadElement = createCommentThreadElement(comments, draftComment, true);
                            const commentCardElement = document.createElement("div");
                            commentCardElement.classList.add("d2h-inline-comment-card");
                            commentCardElement.appendChild(commentThreadElement);
                            insertInlineCommentElementBelowLine(
                                target_gutter.parentElement,
                                commentCardElement,
                                parseInt(line_no)
                            );
                        } else if (draftComment) {
                            console.log("only draft comment exists: ", draftComment);
                            // Insert individual draft comment if only a draft comment exists.
                            insertInlineCommentElementBelowLine(
                                target_gutter.parentElement,
                                createDraftInlineCommentElement(
                                    draftComment.line_number_in_original_diff,
                                    draftComment.preview_diff_id,
                                    draftComment.commentText
                                ),
                                draftComment.line_no
                            );
                        }
                    }
                }
            });
        });
    });
}

function createDraftInlineCommentElement(line_number_in_original_diff, preview_diff_id, draftCommentText) {
    // create editable comment elements for each draft comment with the line number and preview diff id
    // and the comment text pre-filled

    // const currently_selected_preview_diff_id = get_currently_selected_preview_diff_id();

    async function deleteCommentCallback(line_no, preview_diff_id) {
        const success = await deleteInlineComment(line_no, preview_diff_id);
        return success;
    }
    async function saveDraftCommentCallback(line_no, preview_diff_id, commentText) {
        const success = await saveDraftInlineComment(line_no, preview_diff_id, commentText);
        return success;
    }
    async function postInlineCommentCallback(line_no, preview_diff_id, commentText) {
        const success = await postInlineComment(line_no, preview_diff_id, commentText);
        return success;
    }
    async function cancelCommentCallback(line_no, preview_diff_id) {
        // do-nothing for now and just return true to let callback "succeed"
        return true;
    }

    const draftCommentElement = createEditableCommentElement(
        cancelCommentCallback,
        postInlineCommentCallback,
        saveDraftCommentCallback,
        deleteCommentCallback,
        line_number_in_original_diff,
        preview_diff_id,
        draftCommentText,
    );
    return draftCommentElement;
}

function inlineCommentAlreadyExistsAtLine(line_no) {
    const existingComment = document.querySelector(`#d2h-inline-comment-line-${line_no}`);
    return existingComment !== null;
}

function enable_adding_inline_comments_from_diff() {

    console.log("enabling adding inline comments from diff")

    // gutter class is ".d2h-code-side-linenumber" for side-by-side view and ".d2h-code-linenumber" for unified view 
    // add click event listener to each gutter element for unified view
    const gutters = document.querySelector("#custom-diff-area").querySelectorAll(".d2h-code-linenumber");
    gutters.forEach(gutter => {
        const line_no_2_elem = gutter.querySelector(".line-num2");
        if (line_no_2_elem && line_no_2_elem.innerText !== "") {
            gutter.addEventListener("click", () => {
                console.log("gutter clicked")
                const tr_element = gutter.parentElement;
                if (!inlineCommentAlreadyExistsAtLine(parseInt(gutter.innerText))) {
                    createNewEditableInlineComment(tr_element);
                }
            });
        }
        // otherwise, disable mouse events on the gutter element
        // TODO: add ability to parse diff numbers each direction based on whether line number is old or new 
        // this will allow for commenting on deleted lines and lines in the side-by-side view
        else {
            gutter.style.pointerEvents = "none";
        }
    });
    // now enable adding inline comments from side-by-side view but FOR NOW only for new side 
    // find .d2h-files-diff and if it has 2 children, then its side by side view. only look for gutters in the new side
    // (2nd child)
    const sideBySideFiles = document.querySelector("#custom-diff-area").querySelectorAll(".d2h-files-diff");
    sideBySideFiles.forEach(fileDiff => {
        if (fileDiff.children.length === 2) {
            const newSideGutters = fileDiff.children[1].querySelectorAll(".d2h-code-side-linenumber");
            newSideGutters.forEach(gutter => {
                // for side-by-side, the line number is just the innertext of .d2h-code-side-linenumber
                gutter.addEventListener("click", () => {
                    console.log("gutter clicked")
                    const tr_element = gutter.parentElement;
                    if (!inlineCommentAlreadyExistsAtLine(parseInt(gutter.innerText))) {
                        createNewEditableInlineComment(tr_element);
                    }
                });
            });
            // disable mouse events on the old side gutters
            const oldSideGutters = fileDiff.children[0].querySelectorAll(".d2h-code-side-linenumber");
            oldSideGutters.forEach(gutter => {
                gutter.style.pointerEvents = "none";
            });
        }
    });
}

// TODO: find better way of doing this so that we can compare against other inline comments and not just the board comments
function findBoardCommentToInsertAfter(commentDate) {
    // commentDate is a string in the format "2024-03-11T16:32:09.664021+00:00"
    const comments = document.querySelectorAll(".boardComment");
    // target time element:
    // <time itemprop="commentTime" datetime="2024-05-17T09:40:22.517036+00:00" title="2024-05-17 09:40:22 UTC">on
    // 2024-05-17</time>
    let newestComment = null;
    let newestCommentDate = null;
    for (const comment of comments) {
        const times = comment.querySelectorAll("time");
        // find time that has itemprop="commentTime"
        for (const time of times) {
            if (time.getAttribute("itemprop") === "commentTime") {
                if (time.getAttribute("datetime") < commentDate) {
                    // this comment is newer than the current newest comment
                    if (newestCommentDate === null || time.getAttribute("datetime") > newestCommentDate) {
                        newestComment = comment;
                        newestCommentDate = time.getAttribute("datetime");
                    }
                }
            }
        }
    }
    return newestComment;
}

// create a new card that contains X number of lines before the target line number
function createCodeCommentCards(groupedComments, groupedDraftComments) {
    // TODO: add reply functionality 

    const most_recent_preview_diff_id = get_most_recent_preview_diff_id();
    // groupedComments.forEach(fileName => {
    for (const preview_diff_id in groupedComments) {
        for (const file in groupedComments[preview_diff_id]) {
            for (const line_no in groupedComments[preview_diff_id][file]) {
                const comments = groupedComments[preview_diff_id][file][line_no];

                const commentCard = document.createElement("div");
                commentCard.classList.add("d2h-code-comment-card");
                const header = document.createElement("div");
                header.classList.add("d2h-code-comment-card-header");
                const fileName = document.createElement("h3");
                fileName.innerText = file;
                const diffTable = document.createElement("table");
                diffTable.classList.add("d2h-diff-table");
                const diffTableContainer = document.createElement("div");
                diffTableContainer.classList.add("d2h-diff-table-container");
                diffTableContainer.appendChild(diffTable);
                const diffTbody = document.createElement("tbody");
                diffTbody.classList.add("d2h-diff-tbody");
                // const commentsContainer = document.createElement("div");
                // commentsContainer.classList.add("d2h-code-comment-card-comments-container");

                header.appendChild(fileName);
                // if preview_diff_id is not the current / most recent diff, add an "outdated" tag to header
                if (preview_diff_id !== most_recent_preview_diff_id) {
                    const outdatedTag = document.createElement("span");
                    outdatedTag.classList.add("d2h-outdated-tag");
                    outdatedTag.classList.add("d2h-outdated-tag-right-align");
                    outdatedTag.innerText = "Outdated";
                    header.appendChild(outdatedTag);
                }
                commentCard.appendChild(header);
                commentCard.appendChild(diffTableContainer);


                const diffLines = getLinesAroundTargetLine(preview_diff_id, comments[0].file, comments[0].line_no, 4, 0);
                // copy the diff lines into the diffTbody
                diffLines.forEach(line => {
                    const clonedLine = line.cloneNode(true); // clone the line element
                    diffTbody.appendChild(clonedLine); // append the cloned line element
                });
                diffTable.appendChild(diffTbody);


                // // append comments 
                // comments.forEach(comment => {
                //     commentsContainer.appendChild(createInlineCommentElement(comment));
                // });

                // commentCard.appendChild(commentsContainer);

                // TRYING TO USE THE NEW COMMENT THREAD ELEMENT
                let draftComment = null;
                if (preview_diff_id !== most_recent_preview_diff_id) {
                    draftComment = groupedDraftComments[preview_diff_id]?.[file]?.[line_no] || null;
                }
                console.log("found draft comment for code card:", draftComment);
                const commentThreadElement = createCommentThreadElement(comments, draftComment, false);
                commentCard.appendChild(commentThreadElement);

                // find the newest comment to insert after
                const newestComment = findBoardCommentToInsertAfter(comments[0].commentDate);

                // and then insert the comment card after the newest comment
                if (newestComment) {
                    newestComment.insertAdjacentElement("afterend", commentCard);
                }
                else {
                    // insert the comment card into the "#conversation" div
                    document.querySelector("#conversation").appendChild(commentCard);
                }
            }
        }
    }

    // hideAllBoardCommmentsWithInlineComments();
}

async function deleteInlineComment(line_no, preview_diff_id) {
    console.log(`deleting inline comment for line ${line_no} in preview diff ${preview_diff_id}`);

    const mpUrl = document.location.href;
    const lp_microservice_url = MICROSERVICE_BASE_URL + "/cancel_inline_draft_comment";

    try {
        const response = await fetch(lp_microservice_url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                mp_url: mpUrl,
                preview_diff_id: preview_diff_id,
                line_no: line_no,
            })
        });
        const data = await response.json();
        console.log("deleted inline comment:", data);
        return true;
    } catch (error) {
        console.error("error deleting inline comment:", error);
        return false;
    }
}

async function saveDraftInlineComment(line_no, preview_diff_id, commentText) {

    // @app.post("/save_draft_inline_comment")
    // def api_save_draft_inline_comment(mp_url: str, preview_diff_id: Union[str, int], line_no: Union[str, int], comment:
    // str)

    const mpUrl = document.location.href;
    const lp_microservice_url = MICROSERVICE_BASE_URL + "/save_draft_inline_comment";

    console.log("saving draft comment: " + commentText + " to preview diff " + preview_diff_id + " on line " + line_no);

    try {
        const response = await fetch(lp_microservice_url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                mp_url: mpUrl,
                preview_diff_id: preview_diff_id,
                line_no: line_no,
                comment: commentText,
            })
        });
        const data = await response.json();
        console.log("saved draft comment:", data);
        return true;
    } catch (error) {
        console.error("error saving draft comment:", error);
        return false;
    }
}

async function postInlineComment(line_no, preview_diff_id, commentText) {
    // TODO: reverse parse the line number to the diff line number or something
    const mpUrl = document.location.href;

    // send inline comments to local API
    const lp_microservice_url = MICROSERVICE_BASE_URL + "/submit_and_post_inline_comment";
    console.log("posting comment: " + commentText + " to preview diff " + preview_diff_id + " on line " + line_no);

    try {
        const response = await fetch(lp_microservice_url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                mp_url: mpUrl,
                preview_diff_id: preview_diff_id,
                line_no: line_no,
                comment: commentText,
                delete_existing_draft: true, // if the comment being posted was previously saved as a draft, delete the draft
            })
        });
        const data = await response.json();
        console.log("Comment posted successfully:", data);
        return true;
    } catch (error) {
        console.error("Error posting comment:", error);
        return false;
    }
}

function get_line_number_from_gutter_or_line_element(element) {
    // check if the element is a gutter element or tr element
    if (element) {
        // check if element is tr element
        let gutter_element = null;
        if (element.tagName === "TR") {
            gutter_element = element.querySelector(".d2h-code-linenumber") || element.querySelector(".d2h-code-side-linenumber");
            if (!gutter_element) {
                return null;
            }
        } else {
            gutter_element = element;
        }
        // check if .d2h-code-linenumber (unified view) or .d2h-code-side-linenumber (side-by-side view)
        const unified_line_number_elem = element.querySelector(".d2h-code-linenumber");
        if (unified_line_number_elem) {
            return parseInt(unified_line_number_elem.querySelector(".line-num2")?.innerText);
        }
        const side_line_number_elem = element.querySelector(".d2h-code-side-linenumber");
        if (side_line_number_elem) {
            return parseInt(side_line_number_elem.innerText);
        }
    }
    return null;
}

// create new editable inline comment element at the line number in the diff
// triggered by clicking on a line number (gutter) in the diff
function createNewEditableInlineComment(tr_element) {

    // get the line number from the tr element that was clicked on (from the gutter in the diff)
    const line_number_in_file = get_line_number_from_gutter_or_line_element(tr_element);
    // get the file name from the file diff element that the line is in
    const fileName = getFileNameFromDiffLineElement(tr_element);
    // find the line number in the original diff - needed for use in the API
    const line_number_in_original_diff = findLineNumberInDiff(fileName, line_number_in_file, DIFF_TEXT);
    // get the currently selected preview diff id (the one that is currently being viewed)
    const currently_selected_preview_diff_id = get_currently_selected_preview_diff_id();


    const editableComment = createDraftInlineCommentElement(
        line_number_in_original_diff,
        currently_selected_preview_diff_id,
        null
    )

    insertInlineCommentElementBelowLine(tr_element, editableComment, line_number_in_file);

}

function convertMPUrlToAPIUrl(mpUrl) {
    // mp url:
    // https://code.launchpad.net/~a-dubs/cloudware/+git/oraclelib/+merge/455155

    // api url:
    // https://code.launchpad.net/api/devel/~a-dubs/cloudware/+git/oraclelib/+merge/455155

    const api_url = mpUrl.replace("https://code.launchpad.net/", "https://code.launchpad.net/api/devel/");
    return api_url;
}

/**
 * Retrieves all available preview diff IDs from the diff navigator select element.
 *
 * @returns {string[]} An array of preview diff IDs (strings).
 */
function get_all_available_preview_diff_ids() {
    const diff_selector = document.querySelector(".diff-navigator select");
    console.log("diff navigator: ", diff_selector);
    const preview_diff_ids = [];
    for (let i = 0; i < diff_selector.options.length; i++) {
        preview_diff_ids.push(diff_selector.options[i].value);
    }
    console.log("all available preview diff ids: ", preview_diff_ids);
    return preview_diff_ids;
}

/**
 * Gets the currently selected preview diff ID from the diff navigator select element.
 * @returns {string} The currently selected preview diff ID.
 */
function get_currently_selected_preview_diff_id() {
    const diff_selector = document.querySelector(".diff-navigator select");
    const preview_diff_id = diff_selector.options[diff_selector.selectedIndex].value;
    console.log("current preview diff id: " + preview_diff_id);
    return preview_diff_id;
}

/**
 * 
 * @returns the preview diff that is currently the "active" one for the MP. i.e. the most recent one
 */
function get_most_recent_preview_diff_id() {
    const preview_diff_id = document.querySelector(".diff-link").href.split("/")[10];
    return preview_diff_id;
}


function wait_for_diff_navigator_to_load() {
    console.log("waiting for diff navigator to load");
    return new Promise((resolve) => {
        const diffNavigator = document.querySelector(".diff-navigator select");
        if (diffNavigator) {
            console.log("diff navigator already loaded");
            resolve();
        } else {
            // Use the body or a more specific parent node for the observer
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach(addedNode => {
                        // Check if the added node is an element and has the right class
                        if (addedNode.nodeType === Node.ELEMENT_NODE) {
                            // Check if the addedNode or its descendants match the selector
                            if (addedNode.matches(".diff-navigator select") ||
                                addedNode.querySelector(".diff-navigator select")) {
                                console.log("diff navigator loaded");
                                observer.disconnect();
                                resolve();
                            }
                        }
                    });
                });
            });

            // Observe the document body or a more specific parent if needed
            observer.observe(document.body, { childList: true, subtree: true });
        }
    });
}

function boardCommentHasInlineCommentAttached(boardComment) {
    // check if the board comment has an inline comment attached
    // by looking for "boardCommentDetails table td" with "data-preview-diff-id" attribute
    const details_tds = boardComment.querySelectorAll(".boardCommentDetails table td");
    for (const td of details_tds) {
        const previewDiffId = td.getAttribute("data-previewdiff-id");
        if (previewDiffId) {
            return true;
        }
    }
    return false;
}

function hideAllBoardCommmentsWithInlineComments() {
    const boardComments = document.querySelectorAll(".boardComment");
    boardComments.forEach(boardComment => {
        if (boardCommentHasInlineCommentAttached(boardComment)) {
            boardComment.style.display = "none";
        }
    });
}

function create_checkout_changes_locally_button() {
    const checkoutChangesLocallyButton = document.createElement("button");
    checkoutChangesLocallyButton.innerText = "Copy command";
    checkoutChangesLocallyButton.classList.add("checkout-changes-locally-button");

    // get #remote-add tt element inner text
    cmd1 = document.querySelector("tt#remote-add").innerText;
    // get #remote-update tt element inner text
    cmd2 = document.querySelector("tt#remote-update").innerText;
    // get #merge-cmd tt element inner text
    cmd3 = document.querySelector("tt#merge-cmd").innerText;
    // get branch to checkout
    cmd3 = cmd3.replace("git merge", "git checkout");
    // cmd3 = "git switch " + cmd3.replace("git merge ", "").split(" ", 1)[1];

    full_cmd = `${cmd1}\n${cmd2}\n${cmd3}`;
    console.log(full_cmd);
    // add click event listener to copy the command to clipboard
    checkoutChangesLocallyButton.addEventListener("click", () => {
        // copy the command to clipboard
        navigator.clipboard.writeText(full_cmd).then(() => {
            // then alert to the command that was copied to clipboard
            alert("Command copied to clipboard:\n\n" + full_cmd);
        });
    });

    // insert new row into #proposal-summary table at the end
    tr = document.createElement("tr");
    tr.classList.add("checkout-changes-locally-row");
    th = document.createElement("th");
    th.innerText = "Checkout Changes Locally:";
    td = document.createElement("td");
    td.appendChild(checkoutChangesLocallyButton);

    tr.appendChild(th);
    tr.appendChild(td);
    document.querySelector("table#proposal-summary").appendChild(tr);

    return checkoutChangesLocallyButton;
}

///////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////// MAIN FUNCTION ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

function main() {
    ////////////////////// clean up existing elements first //////////////////////
    cleanup_previous_elements()

    ////////////////////// everything else comes after clean up //////////////////////
    create_checkout_changes_locally_button();
    hideAllBoardCommmentsWithInlineComments();
    doCiCdStuff();

    // whenever .diff-content changes, call fetchInlineComments and doCustomDiffStuff
    const diffContent = document.querySelector(".diff-content");
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            console.log(".diff-content mutation observed")
            parseDiffTextFromExistingDiv();
            doCustomDiffStuff();
        });
    });
    observer.observe(diffContent, { childList: true, subtree: false });

    wait_for_diff_navigator_to_load().then(() => {
        console.log("diff navigator loaded");
        doCustomDiffStuff();
        fetchAllPreviewDiffTexts().then(() => {
            createHiddenDiffViewers();
            fetchInlineCommentsAndAddToCustomDiff();
        });
    });

}

if (document.readyState === "complete" || document.readyState === "interactive") {
    console.log("document already loaded")
    main()
}
else {
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded")
        main()
    });
}

// How to implement persistent settings:
// https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Implement_a_settings_page




////////////////////////////////////////// NEW TIMELINE STUFF //////////////////////////////////////////

// Planning of events timeline
/**
 * - MP Comment is left. One of the following must be attached:
 *   - Comment message
 *   - Inline comment(s) - do not show inline comments independently in the timeline, they should be inserted into the
 *     appropriate code comment card
 *   - Review Vote (display the review vote in the timeline, not underneath the comment)
 *   - If there is no comment message, just have the base level timeline event say something like "USER requested
 *     information on Sep 16" or "USER requested changes on Sep 16"
 *   - if review vote was Comment Only, if user is NOT author, then just say "USER reviewed on Sep 16"
 *   - if review vote was Comment Only, if user IS author, then say "USER commented on Sep 16"
 * - Preview Diff ID (aka new code has been pushed) 
 * - CI/CD Result (with link to job run)
 * - review requested
 * - MP status changes (work in progress, needs review, approved, rejected, merged)
*/
function getMPTimelineEvents() {
    // each event will be represented by an object with the following properties:
    // - date
    // - event type specific details object
    // - function to render the event object
    // -

    /** categories of events that will be gathered and then all combined into one array and sorted by date:
     * - comments with optional inline comments attached
     *   - inline comments should be sorted by original line number in diff and then sorted by date in their threads
     * 
    */ 
}

// This will allow for 
function parseReviewVotesFromAPIResponse(reviewVotes) {
    /*
    reviewVote object:
    {
        "self_link": "https://code.launchpad.net/api/devel/~a-dubs/cloudware/+git/oraclelib/+merge/455155/+review/714508",
        "web_link": "https://code.launchpad.net/~a-dubs/cloudware/+git/oraclelib/+merge/455155/+review/714508",
        "resource_type_link": "https://code.launchpad.net/api/devel/#code_review_vote_reference",
        "branch_merge_proposal_link": "https://code.launchpad.net/api/devel/~a-dubs/cloudware/+git/oraclelib/+merge/455155",
        "date_created": "2024-10-24T15:44:58.328532+00:00",
        "registrant_link": "https://code.launchpad.net/api/devel/~a-dubs",
        "reviewer_link": "https://code.launchpad.net/api/devel/~cloudware",
        "review_type": null,
        "comment_link": null,
        "is_pending": true,
        "http_etag": "\"90941231d652a09a261bdcbaef5859946d516e8c-34de75b5cc67b6e8c408a003ad43efeb3d5f2aca\""
    }
    */
    // keep date_created, registrant_link, reviewer_link, is_pending, review_type
    const prasedReviewVotes = [];
    for (const reviewVote of reviewVotes) {
        prasedReviewVotes.push({
            date_created: reviewVote.date_created,
            registrant_link: reviewVote.registrant_link,
            reviewer_link: reviewVote.reviewer_link,
            is_pending: reviewVote.is_pending,
            review_type: reviewVote.review_type,
        });
    }
    console.log("parsed review votes:", prasedReviewVotes);
    return prasedReviewVotes;
}

function fetchReviewVotesFromAPI() {
    // use /votes API endpoint to fetch review votes based on the MP URL
    const api_url = convertMPUrlToAPIUrl(document.location.href) + "/votes";
    console.log("fetching review votes from API at url:", api_url);
    fetch(api_url)
        .then(response => response.json())
        .then(data => {
            const reviewVotes = data.entries;
            console.log("review votes:", reviewVotes);
            return parseReviewVotesFromAPIResponse(reviewVotes);
        })
        .catch(error => console.error('Error fetching review votes from API:', error));
}

function fetchCommentsFromAPI() {
    // fetch from microservice @ /mp/comments with the MP URL encoded as query parameter
    const mpUrl = document.location.href;
    const lp_microservice_url = "http://localhost:8000/mp/comments";
    const encodedMPUrl = encodeURIComponent(mpUrl);
    const url = `${lp_microservice_url}?mp_url=${encodedMPUrl}`;

    fetch(url)
        .then(response => response.json())
        .then(data => {
            console.log("fetched comments:", data);
            return data;
        })
        .catch(error => console.error('Error fetching comments from API:', error));

}

function associateInlineCommentsWithComments(comments, inlineComments) {
    // for each comment, find the inline comments that are associated with it
    // and add them to the comment object
    // if the author of the inline comment is the same as the author of the comment
    // and the inline comment and comment have the same date, then the inline comment is a reply to the comment

}
